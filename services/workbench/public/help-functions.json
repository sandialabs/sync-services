{
  "abs": "(abs x) returns the absolute value of the real number x",
  "acos": "(acos z) returns acos(z); (cos (acos 1)) = 1",
  "acosh": "(acosh z) returns acosh(z)",
  "angle": "(angle z) returns the angle of z",
  "append": "(append ...) returns its argument sequences appended into one sequence",
  "apply": "(apply func ...) applies func to the rest of the arguments",
  "apply-values": "(apply-values var) applies values to var.  This is an internal function.",
  "aritable?": "(aritable? obj num-args) returns #t if 'obj can be applied to 'num-args arguments.",
  "arity": "(arity obj) the min and max acceptable args for obj if it is applicable, otherwise #f.",
  "ash": "(ash i1 i2) returns i1 shifted right or left i2 times, i1 << i2, (ash 1 3) -> 8, (ash 8 -3) -> 1",
  "asin": "(asin z) returns asin(z); (sin (asin x)) = x",
  "asinh": "(asinh z) returns asinh(z)",
  "assoc": "(assoc obj alist (func #f)) returns the key-value pair associated (via equal?) with the key obj in the association list alist.If 'func' is a function of 2 arguments, it is used for the comparison instead of 'equal?",
  "assq": "(assq obj alist) returns the key-value pair associated (via eq?) with the key obj in the association list alist",
  "assv": "(assv obj alist) returns the key-value pair associated (via eqv?) with the key obj in the association list alist",
  "atan": "(atan z) returns atan(z), (atan y x) returns atan(y/x)",
  "atanh": "(atanh z) returns atanh(z)",
  "bignum": "(bignum val (radix 10)) returns a multiprecision version of the string 'val'. If the argument is a number bignum returns that number as a bignum",
  "bignum?": "(bignum? obj) returns #t if obj is a multiprecision number.",
  "boolean?": "(boolean? obj) returns #t if obj is #f or #t: (boolean? ()) -> #f",
  "byte-vector": "(byte-vector ...) returns a byte-vector whose elements are the arguments",
  "byte-vector->expression": "(byte-vector->expression bv) convert a byte vector to an expression",
  "byte-vector->hex-string": "(byte-vector->hex-string bv) convert a byte vector to a hex string",
  "byte-vector->string": "(byte-vector->string obj) turns a byte-vector into a string.",
  "byte-vector-ref": "(byte-vector-ref vect index) returns the byte at the index-th element of the byte-vector vect",
  "byte-vector-set!": "(byte-vector-set! vect index byte) sets the index-th element of the byte-vector vect to the integer byte",
  "byte-vector?": "(byte-vector? obj) returns #t if obj is a byte-vector",
  "byte?": "(byte? obj) returns #t if obj is a byte (an integer between 0 and 255)",
  "caaaar": "(caaaar lst) returns (car (car (car (car lst)))): (caaaar '((((1 2))))) -> 1",
  "caaadr": "(caaadr lst) returns (car (car (car (cdr lst)))): (caaadr '(1 ((2 3)))) -> 2",
  "caaar": "(caaar lst) returns (car (car (car lst))): (caaar '(((1 2)))) -> 1",
  "caadar": "(caadar lst) returns (car (car (cdr (car lst)))): (caadar '((1 (2 3)))) -> 2",
  "caaddr": "(caaddr lst) returns (car (car (cdr (cdr lst)))): (caaddr '(1 2 (3 4))) -> 3",
  "caadr": "(caadr lst) returns (car (car (cdr lst))): (caadr '(1 (2 3))) -> 2",
  "caar": "(caar lst) returns (car (car lst)): (caar '((1 2))) -> 1",
  "cadaar": "(cadaar lst) returns (car (cdr (car (car lst)))): (cadaar '(((1 2 3)))) -> 2",
  "cadadr": "(cadadr lst) returns (car (cdr (car (cdr lst)))): (cadadr '(1 (2 3 4))) -> 3",
  "cadar": "(cadar lst) returns (car (cdr (car lst))): (cadar '((1 2 3))) -> 2",
  "caddar": "(caddar lst) returns (car (cdr (cdr (car lst)))): (caddar '((1 2 3 4))) -> 3",
  "cadddr": "(cadddr lst) returns (car (cdr (cdr (cdr lst)))): (cadddr '(1 2 3 4 5)) -> 4",
  "caddr": "(caddr lst) returns (car (cdr (cdr lst))): (caddr '(1 2 3 4)) -> 3",
  "cadr": "(cadr lst) returns (car (cdr lst)): (cadr '(1 2 3)) -> 2",
  "car": "(car pair) returns the first element of the pair",
  "catch": "(catch tag thunk handler) evaluates thunk; if an error occurs that matches the tag (#t matches all), the handler is called",
  "cdaaar": "(cdaaar lst) returns (cdr (car (car (car lst)))): (cdaaar '((((1 2 3))))) -> '(2 3)",
  "cdaadr": "(cdaadr lst) returns (cdr (car (car (cdr lst)))): (cdaadr '(1 ((2 3 4)))) -> '(3 4)",
  "cdaar": "(cdaar lst) returns (cdr (car (car lst))): (cdaar '(((1 2 3)))) -> '(2 3)",
  "cdadar": "(cdadar lst) returns (cdr (car (cdr (car lst)))): (cdadar '((1 (2 3 4)))) -> '(3 4)",
  "cdaddr": "(cdaddr lst) returns (cdr (car (cdr (cdr lst)))): (cdaddr '(1 2 (3 4 5))) -> '(4 5)",
  "cdadr": "(cdadr lst) returns (cdr (car (cdr lst))): (cdadr '(1 (2 3 4))) -> '(3 4)",
  "cdar": "(cdar lst) returns (cdr (car lst)): (cdar '((1 2 3))) -> '(2 3)",
  "cddaar": "(cddaar lst) returns (cdr (cdr (car (car lst)))): (cddaar '(((1 2 3 4)))) -> '(3 4)",
  "cddadr": "(cddadr lst) returns (cdr (cdr (car (cdr lst)))): (cddadr '(1 (2 3 4 5))) -> '(4 5)",
  "cddar": "(cddar lst) returns (cdr (cdr (car lst))): (cddar '((1 2 3 4))) -> '(3 4)",
  "cdddar": "(cdddar lst) returns (cdr (cdr (cdr (car lst)))): (cdddar '((1 2 3 4 5))) -> '(4 5)",
  "cddddr": "(cddddr lst) returns (cdr (cdr (cdr (cdr lst)))): (cddddr '(1 2 3 4 5)) -> '(5)",
  "cdddr": "(cdddr lst) returns (cdr (cdr (cdr lst))): (cdddr '(1 2 3 4)) -> '(4)",
  "cddr": "(cddr lst) returns (cdr (cdr lst)): (cddr '(1 2 3 4)) -> '(3 4)",
  "cdr": "(cdr pair) returns the second element of the pair",
  "ceiling": "(ceiling x) returns the integer closest to x toward inf",
  "char->integer": "(char->integer c) converts the character c to an integer",
  "char-alphabetic?": "(char-alphabetic? c) returns #t if the character c is alphabetic",
  "char-downcase": "(char-downcase c) converts the character c to lower case",
  "char-lower-case?": "(char-lower-case? c) returns #t if the character c is in lower case",
  "char-numeric?": "(char-numeric? c) returns #t if the character c is a digit",
  "char-position": "(char-position char-or-str str (start 0)) returns the position of the first occurrence of char in str, or #f",
  "char-upcase": "(char-upcase c) converts the character c to upper case",
  "char-upper-case?": "(char-upper-case? c) returns #t if the character c is in upper case",
  "char-whitespace?": "(char-whitespace? c) returns #t if the character c is non-printing character",
  "char<=?": "(char<=? char ...) returns #t if all the character arguments are equal or increasing",
  "char<?": "(char<? char ...) returns #t if all the character arguments are increasing",
  "char=?": "(char=? char ...) returns #t if all the character arguments are equal",
  "char>=?": "(char>=? char ...) returns #t if all the character arguments are equal or decreasing",
  "char>?": "(char>? char ...) returns #t if all the character arguments are decreasing",
  "char?": "(char? obj) returns #t if obj is a character",
  "complex": "(complex x1 x2) returns a complex number with real-part x1 and imaginary-part x2",
  "complex?": "(complex? obj) returns #t if obj is a number",
  "cons": "(cons a b) returns a pair containing a and b",
  "constant?": "(constant? obj) returns #t if obj either evaluates to itself, or is a symbol whose binding is constant",
  "copy": "(copy obj) returns a copy of obj, (copy src dest) copies src into dest, (copy src dest start end) copies src from start to end.",
  "cos": "(cos z) returns cos(z)",
  "cosh": "(cosh z) returns cosh(z)",
  "coverlet": "(coverlet e) undoes an earlier openlet.",
  "crypto-generate": "(crypto-generate seed) returns a public/private key pair derived from the seed",
  "crypto-sign": "(crypto-sign private-key message) return a cryptographic signature",
  "crypto-verify": "(crypto-verify public-key signature message) returns a boolean indicating signature validity",
  "curlet": "(curlet) returns the current definitions (symbol bindings)",
  "cutlet": "(cutlet e symbol ...) removes symbols from the let e.",
  "cyclic-sequences": "(cyclic-sequences obj) returns a list of elements that are cyclic.",
  "defined?": "(defined? symbol (let (curlet)) ignore-globals) returns #t if symbol has a binding (a value) in the let. Only the let is searched if ignore-globals is not #f.",
  "denominator": "(denominator rat) returns the denominator of the rational number rat",
  "display": "(display obj (port (current-output-port))) prints obj",
  "documentation": "(documentation obj) returns obj's documentation string",
  "eof-object?": "(eof-object? val) returns #t if val is the end-of-file object",
  "eq?": "(eq? obj1 obj2) returns #t if obj1 is eq to (the same object as) obj2",
  "equal?": "(equal? obj1 obj2) returns #t if obj1 is equal to obj2",
  "equivalent?": "(equivalent? obj1 obj2) returns #t if obj1 is close enough to obj2.",
  "eqv?": "(eqv? obj1 obj2) returns #t if obj1 is equivalent to obj2",
  "error": "(error type ...) signals an error.  The 'type' can be used with catch to trap particular errors.  If the error is not caught, s7 treats the second argument as a format control string, and applies it to the rest of the arguments.",
  "eval": "(eval code (let (curlet))) evaluates code in the environment let. 'let' defaults to the curlet; to evaluate something in the top-level environment instead, pass (rootlet):\n\n  (define x 32) \n  (let ((x 3))\n    (eval 'x (rootlet)))\n\n  returns 32",
  "eval-string": "(eval-string str (let (curlet))) returns the result of evaluating the string str as Scheme code",
  "even?": "(even? int) returns #t if the integer int32_t is even",
  "exp": "(exp z) returns e^z, (exp 1) is 2.718281828459",
  "expression->byte-vector": "(expression->byte-vector expr) convert a expression string to a byte vector",
  "expt": "(expt z1 z2) returns z1^z2",
  "fill!": "(fill! obj val (start 0) end) fills obj with val",
  "float-vector": "(float-vector ...) returns an homogeneous float vector whose elements are the arguments",
  "float-vector-ref": "(float-vector-ref v ...) returns an element of the float-vector v.",
  "float-vector-set!": "(float-vector-set! v i ... value) sets the i-th element of the float-vector v to value.",
  "float-vector?": "(float-vector? obj) returns #t if obj is an homogeneous float vector",
  "float?": "(float? x) returns #t is x is real and not rational.",
  "floor": "(floor x) returns the integer closest to x toward -inf",
  "for-each": "(for-each proc object . objects) applies proc to each element of the objects traversed in parallel. Each object can be a list, string, vector, hash-table, or any other sequence.",
  "format": "(format out str . args) substitutes args into str sending the result to out. Most of s7's format directives are taken from CL: ~% = newline, ~& = newline if the preceding output character was no a newline, ~~ = ~, ~<newline> trims white space, ~* skips an argument, ~^ exits {} iteration if the arg list is exhausted, ~nT spaces over to column n, ~A prints a representation of any object, ~S is the same, but puts strings in double quotes, ~C prints a character, numbers are handled by ~F, ~E, ~G, ~B, ~O, ~D, and ~X with preceding numbers giving spacing (and spacing character) and precision.  ~{ starts an embedded format directive which is ended by ~}: \n\n  >(format #f \"dashed: ~{~A~^-~}\" '(1 2 3))\n  \"dashed: 1-2-3\"\n\n~P inserts \"s\" if the current it is not 1 or 1.0 (use ~@P for \"ies\" or \"y\").\n~B is number->string in base 2, ~O in base 8, ~D base 10, ~X base 16,\n~E: (format #f \"~E\" 100.1) -&gt; \"1.001000e+02\" (%e in C)\n~F: (format #f \"~F\" 100.1) -&gt; \"100.100000\"   (%f in C)\n~G: (format #f \"~G\" 100.1) -&gt; \"100.1\"        (%g in C)\n\nIf the 'out' it is not an output port, the resultant string is returned.  If it is #t, the string is also sent to the current-output-port.",
  "funclet": "(funclet func) tries to return a function's definition environment",
  "funclet?": "(funclet? obj) returns #t if obj is a funclet (a function's environment).",
  "gcd": "(gcd ...) returns the greatest common divisor of its rational arguments",
  "gensym": "(gensym (prefix \"gensym\")) returns a new, unused symbol",
  "gensym?": "(gensym? sym) returns #t if sym is a gensym",
  "hash-code": "(hash-code obj (eqfunc)) returns an integer suitable for use as a hash code for obj.",
  "hash-table": "(hash-table ...) returns a hash-table containing the symbol/value pairs passed as its arguments. That is, (hash-table 'a 1 'b 2) returns a new hash-table with the two key/value pairs preinstalled.",
  "hash-table-entries": "(hash-table-entries obj) returns the number of entries in the hash-table obj",
  "hash-table-key-typer": "(hash-table-key-typer hash) returns the hash-table's key type checking function",
  "hash-table-ref": "(hash-table-ref table key) returns the value associated with key in the hash table",
  "hash-table-set!": "(hash-table-set! table key value) sets the value associated with key in the hash table to value",
  "hash-table-value-typer": "(hash-table-value-typer hash) returns the hash-table's value type checking function",
  "hash-table?": "(hash-table? obj) returns #t if obj is a hash-table",
  "help": "(help obj) returns obj's documentation",
  "hex-string->byte-vector": "(hex-string->byte-vector str) convert a hex string to a byte vector",
  "imag-part": "(imag-part num) returns the imaginary part of num",
  "immutable!": "(immutable! obj (env (curlet))) declares that the object obj (or obj in env) can't be changed. obj is returned.",
  "immutable?": "(immutable? obj (env (curlet))) returns #t if obj (or obj in env) is immutable",
  "infinite?": "(infinite? obj) returns #t if obj is an infinite real",
  "inlet": "(inlet ...) adds its arguments, each a let, a cons: '(symbol . value), or a keyword/value pair, to a new let, and returns the new let. (inlet :a 1 :b 2) or (inlet '(a . 1) '(b . 2))",
  "int-vector": "(int-vector ...) returns an homogeneous s7_int vector whose elements are the arguments",
  "int-vector-ref": "(int-vector-ref v ...) returns an element of the int-vector v.",
  "int-vector-set!": "(int-vector-set! v i ... value) sets the i-th element of the int-vector v to value.",
  "int-vector?": "(int-vector? obj) returns #t if obj is an homogeneous s7_int vector",
  "integer->char": "(integer->char i) converts the non-negative integer i to a character",
  "integer-decode-float": "(integer-decode-float x) returns a list containing the significand, exponent, and sign of 'x' (1 = positive, -1 = negative).  (integer-decode-float 0.0): (0 0 1)",
  "integer?": "(integer? obj) returns #t if obj is an integer",
  "iterate": "(iterate obj) returns the next element from the iterator obj, or #<eof>.",
  "iterator-at-end?": "(iterator-at-end? iter) returns #t if the iterator has reached the end of its sequence.",
  "iterator-sequence": "(iterator-sequence iterator) returns the sequence that iterator is traversing.",
  "iterator?": "(iterator? obj) returns #t if obj is an iterator.",
  "keyword->symbol": "(keyword->symbol key) returns a symbol with the same name as key but no prepended colon",
  "keyword?": "(keyword? obj) returns #t if obj is a keyword, (keyword? :rest) -> #t",
  "lcm": "(lcm ...) returns the least common multiple of its rational arguments",
  "length": "(length obj) returns the length of obj, which can be a list, vector, string, input-port, or hash-table. The length of a dotted list does not include the final cdr, and is returned as a negative number.  A circular list has infinite length.  Length of anything else returns #f.",
  "let-ref": "(let-ref let sym) returns the value of the symbol sym in the let",
  "let-set!": "(let-set! let sym val) sets the symbol sym's value in the let to val",
  "let?": "(let? obj) returns #t if obj is a let.",
  "list": "(list ...) returns its arguments in a list",
  "list-ref": "(list-ref lst i ...) returns the i-th element (0-based) of the list",
  "list-set!": "(list-set! lst i ... val) sets the i-th element (0-based) of the list to val",
  "list-tail": "(list-tail lst i) returns the list from the i-th element on",
  "list-values": "(list-values ...) returns its arguments in a list (internal to quasiquote)",
  "list?": "(list? obj) returns #t if obj is a pair or null",
  "log": "(log z1 (z2 e)) returns log(z1) / log(z2) where z2 (the base) defaults to e: (log 8 2) = 3",
  "logand": "(logand int32_t ...) returns the AND of its integer arguments (the bits that are on in every argument)",
  "logbit?": "(logbit? int index) returns #t if the index-th bit is on in int, otherwise #f. The argument order here follows gmp, and is the opposite of the CL convention.  (logbit? int bit) is the same as (not (zero? (logand int (ash 1 bit)))).",
  "logior": "(logior int32_t ...) returns the OR of its integer arguments (the bits that are on in any of the arguments)",
  "lognot": "(lognot num) returns the negation of num (its complement, the bits that are not on): (lognot 0) -> -1",
  "logxor": "(logxor int32_t ...) returns the XOR of its integer arguments (the bits that are on in an odd number of the arguments)",
  "macro?": "(macro? arg) returns #t if 'arg' is a macro or a bacro",
  "magnitude": "(magnitude z) returns the magnitude of z",
  "make-byte-vector": "(make-byte-vector len (byte 0)) makes a byte-vector of length len filled with byte.",
  "make-float-vector": "(make-float-vector len (init 0.0)) returns a float-vector.",
  "make-hash-table": "(make-hash-table (size 8) eq-func typer) returns a new hash table. eq-func is the function used to check equality of keys; it usually defaults to equal?. typer sets the types of the keys and values that are allowed in the table; it is a cons, defaulting to (cons #t #t) which means any types are allowed.\n",
  "make-int-vector": "(make-int-vector len (init 0)) returns an int-vector.",
  "make-iterator": "(make-iterator sequence carrier) returns an iterator object that returns the next value in the sequence each time it is called.  When it reaches the end, it returns #<eof>.",
  "make-list": "(make-list length (initial-element #f)) returns a list of 'length' elements whose value is 'initial-element'.",
  "make-string": "(make-string len (val #\\space)) makes a string of length len filled with the character val (default: space)",
  "make-vector": "(make-vector len (value #<unspecified>) type) returns a vector of len elements initialized to value. To create a multidimensional vector, put the dimension bounds in a list (this is to avoid ambiguities such as (make-vector 1 2) where it's not clear whether the '2' is an initial value or a dimension size).  (make-vector '(2 3) 1.0) returns a 2 dimensional vector of 6 total elements, all initialized to 1.0. The 'type argument can set the element type. It is a function that checks the new value, returning #f if the value is not acceptable: (make-vector 8 1/2 rational?).",
  "make-weak-hash-table": "(make-weak-hash-table (size 8) eq-func typers) returns a new weak hash table",
  "map": "(map proc object . objects) applies proc to a list made up of the next element of each of its arguments, returning a list of the results.  Its arguments can be lists, vectors, strings, hash-tables, or any applicable objects.",
  "max": "(max ...) returns the maximum of its arguments",
  "member": "(member obj list (func #f)) looks for obj in list and returns the list from that point if it is found, otherwise #f. member uses equal?  If 'func' is a function of 2 arguments, it is used for the comparison instead of 'equal?",
  "memq": "(memq obj list) looks for obj in list and returns the list from that point if it is found, otherwise #f. memq uses eq?",
  "memv": "(memv obj list) looks for obj in list and returns the list from that point if it is found, otherwise #f. memv uses eqv?",
  "min": "(min ...) returns the minimum of its arguments",
  "modulo": "(modulo x1 x2) returns x1 mod x2; (modulo 4 3) = 1.  The arguments can be real numbers.",
  "nan": "(nan int) returns a NaN with payload int",
  "nan-payload": "(nan-payload x) returns the payload associated with the NaN x",
  "nan?": "(nan? obj) returns #t if obj is a NaN",
  "negative?": "(negative? num) returns #t if the real number num is negative (less than 0)",
  "newline": "(newline (port (current-output-port))) writes a carriage return to the port",
  "not": "(not obj) returns #t if obj is #f, otherwise #t: (not ()) -> #f",
  "null?": "(null? obj) returns #t if obj is the empty list",
  "number->string": "(number->string num (radix 10)) converts the number num into a string.",
  "number?": "(number? obj) returns #t if obj is a number",
  "numerator": "(numerator rat) returns the numerator of the rational number rat",
  "object->let": "(object->let obj) returns a let (namespace) describing obj.",
  "object->string": "(object->string obj (write #t) (max-len (*s7* 'most-positive-fixnum))) returns a string representation of obj.",
  "odd?": "(odd? int) returns #t if the integer int32_t is odd",
  "open-input-string": "(open-input-string str) opens an input port reading str",
  "openlet": "(openlet e) tells the built-in generic functions that the let 'e might have an over-riding method.",
  "openlet?": "(openlet? obj) returns #t is 'obj' has methods.",
  "outlet": "(outlet let) is the environment that contains let.",
  "pair?": "(pair? obj) returns #t if obj is a pair (a non-empty list)",
  "positive?": "(positive? num) returns #t if the real number num is positive (greater than 0)",
  "print": "(print obj ...) print objects to the console and returns the last object",
  "procedure-source": "(procedure-source func) tries to return the definition of func",
  "procedure?": "(procedure? obj) returns #t if obj is a procedure",
  "proper-list?": "(proper-list? x) returns #t is x is a list that is neither circular nor dotted.",
  "provide": "(provide symbol) adds symbol to the *features* list",
  "provided?": "(provided? symbol) returns #t if symbol is a member of the *features* list",
  "quasiquote": "(quasiquote arg) is the same as `arg.  If arg is a list, it can contain comma (\"unquote\") and comma-atsign (\"apply values\") to pre-evaluate portions of the list. unquoted expressions are evaluated and plugged into the list, apply-values evaluates the expression and splices the resultant list into the outer list. `(1 ,(+ 1 1) ,@(list 3 4)) -> (1 2 3 4).",
  "quotient": "(quotient x1 x2) returns the integer quotient of x1 and x2; (quotient 4 3) = 1",
  "random-byte-vector": "(random-byte-vector length) generate a securely random byte vector of the provided length",
  "random-state": "(random-state seed (carry plausible-default)) returns a new random number state initialized with 'seed'. Pass this as the second argument to 'random' to get a repeatable random number sequence:\n    (let ((seed (random-state 1234))) (random 1.0 seed))",
  "random-state->list": "(random-state->list r) returns the random state object as a list.You can later apply random-state to this list to continue a random number sequence from any point.",
  "random-state?": "(random-state? obj) returns #t if obj is a random-state object (from random-state).",
  "rational?": "(rational? obj) returns #t if obj is a rational number (either an integer or a ratio)",
  "rationalize": "(rationalize x err) returns the ratio with smallest denominator within err of x",
  "read": "(read (port (current-input-port))) returns the next object in the input port, or #<eof> at the end",
  "real-part": "(real-part num) returns the real part of num",
  "real?": "(real? obj) returns #t if obj is a real number",
  "remainder": "(remainder x1 x2) returns the remainder of x1/x2; (remainder 10 3) = 1",
  "reverse": "(reverse lst) returns a list with the elements of lst in reverse order.  reverse also accepts a string or vector argument.",
  "reverse!": "(reverse! lst) reverses lst in place",
  "rootlet": "(rootlet) returns the current top-level definitions (symbol bindings).",
  "round": "(round x) returns the integer closest to x",
  "sequence?": "(sequence? obj) returns #t if obj is a sequence (vector, string, pair, etc)",
  "set-car!": "(set-car! pair val) sets the pair's first element to val",
  "set-cdr!": "(set-cdr! pair val) sets the pair's second element to val",
  "setter": "(setter obj let) returns the setter associated with obj",
  "signature": "(signature obj) returns obj's signature",
  "sin": "(sin z) returns sin(z)",
  "sinh": "(sinh z) returns sinh(z)",
  "sort!": "(sort! sequence less?) sorts a sequence using the function 'less?' to compare elements.",
  "sqrt": "(sqrt z) returns the square root of z",
  "string": "(string chr...) appends all its character arguments into one string",
  "string->byte-vector": "(string->byte-vector obj) turns a string into a byte-vector.",
  "string->keyword": "(string->keyword str) prepends ':' to str and defines that as a keyword",
  "string->number": "(string->number str (radix 10)) converts str into a number. If str does not represent a number, string->number returns #f.  If 'str' has an embedded radix, the optional 'radix' argument is ignored: (string->number \"#x11\" 2) -> 17 not 3.",
  "string->symbol": "(string->symbol str) returns the string str converted to a symbol",
  "string-append": "(string-append str1 ...) appends all its string arguments into one string",
  "string-copy": "(string-copy str dest-str (dest-start 0) dest-end) returns a copy of its string argument.  If dest-str is given,     string-copy copies its first argument into the second, starting at dest-start in the second string and returns dest-str",
  "string-downcase": "(string-downcase str) returns the lower case version of str.",
  "string-position": "(string-position str1 str2 (start 0)) returns the starting position of str1 in str2 or #f",
  "string-ref": "(string-ref str index) returns the character at the index-th element of the string str",
  "string-set!": "(string-set! str index chr) sets the index-th element of the string str to the character chr",
  "string-upcase": "(string-upcase str) returns the upper case version of str.",
  "string<=?": "(string<=? str ...) returns #t if all the string arguments are equal or increasing",
  "string<?": "(string<? str ...) returns #t if all the string arguments are increasing",
  "string=?": "(string=? str ...) returns #t if all the string arguments are equal",
  "string>=?": "(string>=? str ...) returns #t if all the string arguments are equal or decreasing",
  "string>?": "(string>? str ...) returns #t if all the string arguments are decreasing",
  "string?": "(string? obj) returns #t if obj is a string",
  "sublet": "(sublet let ...) makes a new let within the environment 'let', initializing it with the bindings",
  "substring": "(substring str start (end (length str))) returns the portion of the string str between start and end: (substring \"01234\" 1 2) -> \"1\"",
  "subvector": "(subvector original-vector (start 0) (end original-vector-len) new-dimensions) returns a vector that points to the same elements as the original-vector but with different starting point, end point, and dimensional info.",
  "subvector-position": "(subvector-position obj) returns obj's offset",
  "subvector-vector": "(subvector-vector obj) returns the vector underlying the subvector obj",
  "subvector?": "(subvector? obj) returns #t if obj is a subvector",
  "symbol": "(symbol str ...) returns its string arguments concatenated and converted to a symbol",
  "symbol->dynamic-value": "(symbol->dynamic-value sym) returns the dynamic binding of the symbol sym",
  "symbol->keyword": "(symbol->keyword sym) returns a keyword with the same name as sym, but with a colon prepended",
  "symbol->string": "(symbol->string sym) returns the symbol sym converted to a string",
  "symbol->value": "(symbol->value sym (let (curlet))) returns the binding of (the value associated with) the symbol sym in the given let: (let ((x 32)) (symbol->value 'x)) -> 32",
  "symbol-table": "(symbol-table) returns a vector containing the current symbol-table symbols",
  "sync-all": "(sync-all) list all synchronic record IDs in ascending order",
  "sync-call": "(sync-call query blocking? id) query the provided record ID or self if ID not provided",
  "sync-car": "(sync-car pair) retrieve the first element of a sync pair",
  "sync-cdr": "(sync-cdr pair) retrieve the second element of a sync pair",
  "sync-cons": "(sync-cons first rest) construct a new sync pair node",
  "sync-create": "(sync-create id) create a new synchronic record with the given 32-byte ID",
  "sync-cut": "(sync-cut value) obtain the stub of a sync pair or byte vector",
  "sync-delete": "(sync-delete id) delete the synchronic record with the given 32-byte ID",
  "sync-digest": "(sync-digest node) returns the the digest of a sync-node as a byte-vector",
  "sync-hash": "(sync-hash bv) compute the SHA-256 digest of a byte vector",
  "sync-http": "(sync-http method url . data) make an http request where method is 'get or 'post",
  "sync-node": "(sync-node digest) returns the sync pair defined by the digest",
  "sync-node?": "(sync-node?) returns whether the object is a sync node",
  "sync-null": "(sync-null) returns the null synchronic node",
  "sync-null?": "(sync-null? sp) returns a boolean indicating whether sp is equal to sync-null",
  "sync-pair?": "(sync-pair? sp) returns a boolean indicating whether sp is a pair",
  "sync-remote": "(sync-remote url data) make a post http request with the data payload)",
  "sync-stub": "(sync-stub digest) create a sync stub from the provided byte-vector",
  "sync-stub?": "(sync-stub? sp) returns a boolean indicating whether sp is a stub",
  "syntax?": "(syntax? obj) returns #t if obj is a syntactic value (e.g. lambda)",
  "tan": "(tan z) returns tan(z)",
  "tanh": "(tanh z) returns tanh(z)",
  "throw": "(throw tag . info) is like (error ...) but it does not affect owlet. It looks for an existing catch with a matching tag, and jumps to it if found.  Otherwise it raises an error.",
  "time-unix": "(time-unix) returns current Unix time in seconds",
  "tree-count": "(tree-count obj tree max-count) returns how many times obj is in tree (using eq?), stopping at max-count (if specified)",
  "tree-cyclic?": "(tree-cyclic? tree) returns #t if the tree has a cycle.",
  "tree-leaves": "(tree-leaves tree) returns the number of leaves in the tree",
  "tree-memq": "(tree-memq obj tree) is a tree-oriented version of memq, but returning #t if the object is in the tree.",
  "tree-set-memq": "(tree-set-memq symbols tree) returns #t if any of the list of symbols is in the tree",
  "truncate": "(truncate x) returns the integer closest to x toward 0",
  "type-of": "(type-of obj) returns a symbol describing obj's type",
  "undefined?": "(undefined? val) returns #t if val is #<undefined> or its reader equivalent",
  "unspecified?": "(unspecified? val) returns #t if val is #<unspecified>",
  "values": "(values obj ...) splices its arguments into whatever list holds it (its 'continuation')",
  "varlet": "(varlet target-let ...) adds its arguments (a let, a cons: symbol . value, or two arguments, the symbol and its value) to the let target-let, and returns target-let.  (varlet (curlet) 'a 1) adds 'a to the current environment with the value 1.",
  "vector": "(vector ...) returns a vector whose elements are the arguments",
  "vector-dimension": "(vector-dimension vect n) returns the size of the n-th dimension (n is 0-based)",
  "vector-dimensions": "(vector-dimensions vect) returns a list of vect's dimensions",
  "vector-rank": "(vector-rank vect) returns the number of dimensions in vect",
  "vector-ref": "(vector-ref v ... i) returns the i-th element of vector v.",
  "vector-set!": "(vector-set! v i ... value) sets the i-th element of vector v to value.",
  "vector-typer": "(vector-typer vect) returns the vector's element type checking function",
  "vector?": "(vector? obj) returns #t if obj is a vector",
  "weak-hash-table": "(weak-hash-table ...) returns a weak-hash-table containing the symbol/value pairs passed as its arguments. That is, (weak-hash-table 'a 1 'b 2) returns a new weak-hash-table with the two key/value pairs preinstalled.",
  "weak-hash-table?": "(weak-hash-table? obj) returns #t if obj is a weak hash-table",
  "with-input-from-string": "(with-input-from-string str thunk) opens str as the temporary current-input-port and calls thunk",
  "zero?": "(zero? num) returns #t if the number num is zero",
  "*s7*": "*s7* is a let that gives access to s7's internal state: e.g. (*s7* 'print-length)",
  "+": "(+ ...) adds its arguments",
  "-": "(- x1 ...) subtracts its trailing arguments from the first, or negates the first if only one it is given",
  "/": "(/ x1 ...) divides its first argument by the rest, or inverts the first if there is only one argument",
  "<": "(< x1 ...) returns #t if its arguments are in increasing order",
  "<=": "(<= x1 ...) returns #t if its arguments are in non-decreasing order",
  "<list*>": "<list*>: CL list* (I think) for quasiquote's internal use",
  "=": "(= z1 ...) returns #t if all its arguments are equal",
  ">": "(> x1 ...) returns #t if its arguments are in decreasing order",
  ">=": "(>= x1 ...) returns #t if its arguments are in non-increasing order",
  "[list*]": "<list*>: CL list* (I think) for quasiquote's internal use"
}
